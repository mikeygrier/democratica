#    MeritCommons Portal
#    Copyright 2013 Wayne State University
#    All Rights Reserved

package MeritCommons::ContentDriver;

=head1 NAME

MeritCommons::ContentDriver - Base class and interface for MeritCommons::ContentDriver classes

=head1 SYNOPSIS

=head2 METHODS

=over 4

=item * 
  new - generic constructor

=item * 
  should_handle - subclasses should override to declare what messages they handle.

=item * 
  inbound - for data in, called by MeritCommons::Controller::Inbound among other things

=item * 
  outbound - massage data out, called by prepare_payload

=item * 
  notification - here's the default notification

=back 

=head2 CONSTANTS

These roughly define when the subclassed ContentDriver should be called.

=over 4

=item * FIRST

=item * EARLIER

=item * EARLY

=item * WHENEVER

=item * LATE

=item * LATER

=item * LAST

=back 

=head1 DESCRIPTION

MeritCommons::ContentDriver provides a base class and interface for any Content Drivers
in meritcommons, which will allow for richer messages with embedded media,
markup, and other fun things.

=cut

=head1 FUNCTIONS

=cut

use Mojo::Base -base;

use constant FIRST    => 1;
use constant EARLIER  => 15;
use constant EARLY    => 30;
use constant WHENEVER => 45;
use constant LATE     => 60;
use constant LATER    => 75;
use constant LAST     => 90;

use Exporter 'import';

our @EXPORT = qw/
  FIRST EARLIER EARLY WHENEVER LATE LATER LAST
  /;

=head2 C<new>

  new(\$args);

C<new> is a typical constructor, returning a blessed object. It does not
need to be overridden by subclasses.

=cut

sub new {
    my ($class, $args) = @_;

    my $self;
    if (ref($args)) {
        $self = bless $args, $class;
    } else {
        $self = bless {}, $class;
    }

    # if we have a setup routine defined call it (in case people want to use
    # this amazing constructor)
    if ($self->can('setup')) {
        $self->setup();
    }

    return $self;
}

=head2 C<should_handle>

  should_handle();

Here, C<should_handle> takes in no argumens, and simply warns that this wasn't
overridden and returns undef.

In subclasses, C<should_handle> should return a boolean indicating whether or
not It handles a given message type, which is contained in $self->{for}. 

=cut

sub should_handle {
    my ($self, $controller, $content, $actor, $action) = @_;
    if (exists $self->handles->{$action} && ref $self->handles->{$action} eq "ARRAY") {

        foreach my $type (@{ $self->handles->{$action} }) {
            if ($type eq "all" || $type eq $self->{for}) {
                return 1;
            }
        }
    }

    return undef;
}

sub priority {
    my ($self) = @_;
    if (exists($self->priorities->{ $self->{for} })) {
        return $self->priorities->{ $self->{for} };
    } elsif (exists($self->priorities->{all})) {
        return $self->priorities->{all};
    }
    return undef;
}

=head2 C<inbound>

  inbound($controller, $content, $actor);

C<inbound> is called by MeritCommons::Controller::Inbound and other things. It's
primarily where the magic happens for most ContentDrivers, where you might 
(for example) swap some keywords or tagged text for an piece of embedded media,
or whatever you're doing. For examples, look at some of the the included
Drivers, such as MeritCommons::ContentDriver::Flickr or
MeritCommons::ContentDriver::YouTube or even MeritCommons::ContentDriver::Latex

In this superclass, it just sends a warning to remind a lazy or forgetful
ContentDriver author that they didn't override this method, and then
returns C<$content>.

=cut

sub inbound {
    my ($self, $controller, $content) = @_;
    warn "[bad]: this ContentDriver " .
      ref($self) . " did not implement inbound(), and now someone's trying to write data to it.  way to go.\n";
    return $content;
}

=head2 C<outbound>

  outbound($controller, $content, $actor);

C<outbound> massages the data going out, and is called by prepare_payload. In subclasses,
this means doing things like setting the user's avatar, the message time, and
other metadata to make it ready for display.

In this superclass, much like C<inbound> and C<should_handle>, it just sends a warning
to remind a lazy or forgetful ContentDriver author that they didn't override this method,
and then returns C<$content>.

=cut

sub outbound {
    my ($self, $controller, $content) = @_;
    warn "[bad]: this ContentDriver " .
      ref($self) . " did not implement outbound(), and now someone's trying to read data from it.  *sigh*\n";
    return $content;
}

=head2 C<notification>

  notification($controller, $content, $notifier);

C<notification> handles the appearance and text of notifcations generated by
the messages this ContentDriver handles. It's not required to be overridden,
but if it isn't, the notification will just a generic default message.

=cut

sub notification {
    my ($self, $controller, $content, $notifier) = @_;
    return $content;
}

1;
